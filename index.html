<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>杜佳甲老婆</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body { height:100%; margin:0; overflow:hidden; background:#000; font-family:Helvetica, sans-serif; }
        #container { width:100%; height:100%; }
        .element { width:150px; height:150px; box-shadow:0 0 12px rgba(0,255,255,.5); border:1px solid rgba(127,255,255,.25); display:block; }
        /* canvas 占用 element 大小 */
        .element canvas { display:block; width:150px; height:150px; border-radius:4px; }
        #menu { position:fixed; bottom:20px; width:100%; text-align:center; z-index:10; }
        button { background:transparent; border:1px solid rgba(127,255,255,.75); color:rgba(127,255,255,.75); padding:6px 12px; margin:0 5px; cursor:pointer; }
        .show_info { position:fixed; top:30%; left:0; right:0; margin:auto; width:340px; background:rgba(0,0,0,.7); padding:10px; border-radius:6px; display:none; box-shadow:0 0 10px #fff; text-align:center; z-index:20; }
        .show_info img { width:240px; max-width:100%; border-radius:5px; }
        .intro { color:#fff; margin-top:10px; }
    </style>
    <link rel="stylesheet" href="css/animate.min.css">
</head>
<body>
<div id="container"></div>

<div id="menu">
    <button id="table">表格</button>
    <button id="sphere">球形</button>
    <button id="helix">螺旋</button>
    <button id="grid">网格</button>
</div>

<div class="show_info animated">
    <img src="img/d1.jpg" alt="info image">
    <div class="intro">愿与君朝朝暮暮，朝为始，暮不至</div>
</div>

<script src="js/jquery.min.js"></script>
<script src="js/three.js"></script>
<script src="js/tween.min.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/CSS3DRenderer.js"></script>

<script>
/* ================= 数据 ================= */
const personArray = [];
for (let i = 0; i < 200; i++) {
    // 建议提供更高分辨率的图片，例如 d@2x.jpg，如果没有，仍使用 d.jpg
    personArray.push({ image: 'img/d.jpg' });
}
const table = personArray.map((p, i) => ({
    image: p.image,
    p_x: (i % 20) + 1,
    p_y: Math.floor(i / 20) + 1
}));

/* ================= Three.js 初始化 ================= */
let camera, scene, renderer, controls;
const objects = [];
const targets = { table: [], sphere: [], helix: [], grid: [] };
init();
animate();

function init() {
    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 3000;
    scene = new THREE.Scene();

    // 每个卡片用 canvas（按 devicePixelRatio 绘制以保证清晰度）
    const DISPLAY_SIZE = 150; // CSS 显示大小（px），可改大到 180/200 进一步清晰

    table.forEach((item, i) => {
        const element = document.createElement('div');
        element.className = 'element';
        element.style.width = DISPLAY_SIZE + 'px';
        element.style.height = DISPLAY_SIZE + 'px';

        // 创建 canvas 并按 DPR 缩放像素缓冲
        const canvas = document.createElement('canvas');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(DISPLAY_SIZE * dpr);
        canvas.height = Math.round(DISPLAY_SIZE * dpr);
        canvas.style.width = DISPLAY_SIZE + 'px';
        canvas.style.height = DISPLAY_SIZE + 'px';
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        // 载入图片并绘制到 canvas，高质量缩放
        const img = new Image();
        img.onload = function() {
            // 保持纵横比并居中裁剪（cover）
            const sw = img.width, sh = img.height;
            const dw = canvas.width, dh = canvas.height;
            const imgRatio = sw / sh;
            const canvasRatio = dw / dh;
            let sx = 0, sy = 0, sWidth = sw, sHeight = sh;
            if (imgRatio > canvasRatio) {
                // 图片更宽 -> 裁掉左右
                sWidth = Math.round(sh * canvasRatio);
                sx = Math.round((sw - sWidth) / 2);
            } else {
                // 图片更高 -> 裁掉上下
                sHeight = Math.round(sw / canvasRatio);
                sy = Math.round((sh - sHeight) / 2);
            }
            ctx.clearRect(0,0,dw,dh);
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, dw, dh);
        };
        // 设置跨域属性（若图片来自外部），本地项目通常不需
        img.crossOrigin = "anonymous";
        img.src = item.image;

        element.appendChild(canvas);

        const cssObj = new THREE.CSS3DObject(element);
        cssObj.position.set(Math.random() * 4000 - 2000, Math.random() * 4000 - 2000, Math.random() * 4000 - 2000);
        scene.add(cssObj);
        objects.push(cssObj);

        const target = new THREE.Object3D();
        target.position.x = item.p_x * 140 - 1330;
        target.position.y = - item.p_y * 180 + 990;
        targets.table.push(target);
    });

    // sphere
    const spherical = new THREE.Spherical();
    for (let i = 0, l = objects.length; i < l; i++) {
        const obj = new THREE.Object3D();
        const phi = Math.acos(-1 + (2 * i) / l);
        const theta = Math.sqrt(l * Math.PI) * phi;
        spherical.set(800, phi, theta);
        obj.position.setFromSpherical(spherical);
        targets.sphere.push(obj);
    }

    // helix
    const cylindrical = new THREE.Cylindrical();
    for (let i = 0, l = objects.length; i < l; i++) {
        const obj = new THREE.Object3D();
        cylindrical.set(900, i * 0.175 + Math.PI, - i * 5 + 450);
        obj.position.setFromCylindrical(cylindrical);
        targets.helix.push(obj);
    }

    // grid
    for (let i = 0; i < objects.length; i++) {
        const obj = new THREE.Object3D();
        obj.position.x = (i % 5) * 400 - 800;
        obj.position.y = - (Math.floor(i / 5) % 5) * 300 + 500;
        obj.position.z = Math.floor(i / 25) * 200 - 800;
        targets.grid.push(obj);
    }

    renderer = new THREE.CSS3DRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new THREE.TrackballControls(camera, renderer.domElement);
    controls.minDistance = 500;
    controls.maxDistance = 6000;

    document.getElementById('table').onclick = () => transform(targets.table, 2000);
    document.getElementById('sphere').onclick = () => transform(targets.sphere, 2000);
    document.getElementById('helix').onclick = () => transform(targets.helix, 2000);
    document.getElementById('grid').onclick = () => transform(targets.grid, 2000);

    transform(targets.table, 2000);
    window.addEventListener('resize', onResize);
}

function transform(targets, duration) {
    TWEEN.removeAll();
    objects.forEach((obj, i) => {
        new TWEEN.Tween(obj.position)
            .to({ x: targets[i].position.x, y: targets[i].position.y, z: targets[i].position.z }, Math.random() * duration + duration)
            .easing(TWEEN.Easing.Exponential.InOut)
            .start();
        new TWEEN.Tween(obj.rotation)
            .to({ x: targets[i].rotation.x, y: targets[i].rotation.y, z: targets[i].rotation.z }, Math.random() * duration + duration)
            .easing(TWEEN.Easing.Exponential.InOut)
            .start();
    });
    new TWEEN.Tween(this).to({}, duration * 2).onUpdate(render).start();
}

function animate() { requestAnimationFrame(animate); TWEEN.update(); controls.update(); render(); }
function render() { renderer.render(scene, camera); }
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
